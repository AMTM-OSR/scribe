#!/bin/sh -
#
# NB: rc.func only runs PRECMD on "start"
# Last Modified: 2026-Jan-31
# VERSION="3.1.5"
#-------------------------------------------

## Run the F/W built-in native commands ##
grepCmd="/bin/grep"
headCmd="/usr/bin/head"
psCmd="$(which -a ps | $grepCmd -v '^/opt/' | $headCmd -n1)"
rmCmd="$(which -a rm | $grepCmd -v '^/opt/' | $headCmd -n1)"
lnCmd="$(which -a ln | $grepCmd -v '^/opt/' | $headCmd -n1)"
lsCmd="$(which -a ls | $grepCmd -v '^/opt/' | $headCmd -n1)"
awkCmd="$(which -a awk | $grepCmd -v '^/opt/' | $headCmd -n1)"
catCmd="$(which -a cat | $grepCmd -v '^/opt/' | $headCmd -n1)"
cutCmd="$(which -a cut | $grepCmd -v '^/opt/' | $headCmd -n1)"
pidofCmd="$(which -a pidof | $grepCmd -v '^/opt/' | $headCmd -n1)"
loggerCmd="$(which -a logger | $grepCmd -v '^/opt/' | $headCmd -n1)"
logTagStr="scribe:kill_logger[$$]"
logPrioNum="-p 4"

##----------------------------------------##
## Modified by Martinski W. [2026-Jan-30] ##
##----------------------------------------##
kill_logger()
{
    local serviceCallOK  prevSysLog_Loc  messagesLogSAVED
    local scribeScriptFPath="/jffs/scripts/scribe"
    local booleanStr=false  filterSyslogInitRebootLogMsgs=true
    local syslogD_InitRebootLogPath="/opt/var/log/syslogd.ScribeInitReboot.LOG"
    local syslogNG_WaitnSEM_FPath="/tmp/var/tmp/scribe_SysLogNg.WAITN.SEM"
    local syslogNG_StartSEM_FPath="/tmp/var/tmp/scribe_SysLogNg.START.SEM"

    if [ $# -eq 0 ] || [ -z "$1" ] || [ "$1" = "true" ]
    then
        serviceCallOK=true
    else
        serviceCallOK=false
        [ ! -f "$syslogNG_StartSEM_FPath" ] && exit 1
    fi

    # If START Semaphore NOT found, call Scribe to set it up after a specified delay #
    if [ ! -f "$syslogNG_StartSEM_FPath" ]
    then
        $loggerCmd -t "$logTagStr" $logPrioNum "Calling Scribe SysLogNgStartDelay..."
        [ ! -f "$syslogNG_WaitnSEM_FPath" ] && echo "150" > "$syslogNG_WaitnSEM_FPath"
        nohup "$scribeScriptFPath" SysLogNgStartDelay >/dev/null 2>&1 &
        exit 1
    fi
    $rmCmd -f "$syslogNG_WaitnSEM_FPath"  #Done waiting. We can start now#

    # These will be set if coming from Scribe; on bootup, these will NOT be set #
    [ -z "$tmplog" ] && tmplog="/tmp/syslog.log"
    [ -z "$jffslog" ] && jffslog="/jffs/syslog.log"
    [ -z "$optmsg" ] && optmsg="/opt/var/log/messages"
    [ -z "$script_conf" ] && script_conf="/jffs/addons/scribe.d/config"
    isjffs=false
    prevSysLog_Loc="$syslog_loc"
    messagesLogSAVED="${optmsg}.Scribe_SAVED.LOG"

    # Figure out where syslogd expects log file to live #
    if [ -z "$syslog_loc" ]  # do NOT look for config file if $syslog_loc is defined #
    then
        if [ -s "$script_conf" ] && $grepCmd -q "^SYSLOG_LOC=" "$script_conf"
        then
            syslog_loc="$($grepCmd "^SYSLOG_LOC=" "$script_conf" | $cutCmd -d'=' -f2)"
        elif [ -n "$($pidofCmd syslogd)" ]
        then
            findStr="$($psCmd ww | $grepCmd '/syslogd' | $grepCmd -oE '\-O .*/syslog.log')"
            if [ -n "$findStr" ]
            then
                syslog_loc="$(echo "$findStr" | $awkCmd -F' ' '{print $2}')"
            elif [ -z "$syslog_loc" ]
            then
                syslog_loc="$tmplog"  # Make a reasonable guess #
            fi
        elif [ -z "$syslog_loc" ]
        then  # NO config file, $syslog_loc not set, & syslogd not running!!! 
            syslog_loc="$tmplog"  # Make a reasonable guess #
        fi
    fi

    if [ -s "$script_conf" ] && \
       $grepCmd -q "^FILTER_INIT_REBOOT_LOG=" "$script_conf"
    then
        booleanStr="$($grepCmd "^FILTER_INIT_REBOOT_LOG=" "$script_conf" | $cutCmd -d'=' -f2)"
    fi
    if [ "$booleanStr" = "true" ]
    then filterSyslogInitRebootLogMsgs=true
    else filterSyslogInitRebootLogMsgs=false
    fi

    if "$serviceCallOK"
    then
        $loggerCmd -t "$logTagStr" $logPrioNum "optmsg=[$optmsg]"
        $loggerCmd -t "$logTagStr" $logPrioNum "syslog_loc=[$syslog_loc]"
        $loggerCmd -t "$logTagStr" $logPrioNum "script_conf=[$script_conf]"
    fi

    [ "$syslog_loc" = "$jffslog" ] && isjffs=true

    # Touch 'logrotate.status' if it doesn't exist so syslog-ng doesn't whine #
    [ ! -f /var/lib/logrotate.status ] && touch /var/lib/logrotate.status

    ##----------------------------------------##
    ## Modified by Martinski W. [2025-Jun-16] ##
    ##----------------------------------------##
    # Set correct permissions to avoid "world-readable" status #
    chmod 600 /var/lib/logrotate.status

    # Export timezone if not already set #
    [ -z "${TZ:+xSETx}" ] && export TZ="$($catCmd /etc/TZ)"

    if [ "$prevSysLog_Loc" = "$syslog_loc" ] && ! "$serviceCallOK"
    then return 0
    fi

    ##----------------------------------------##
    ## Modified by Martinski W. [2026-Jan-10] ##
    ##----------------------------------------##
    # Kill any/all running klogd and/or syslogd #
    [ -n "$( $pidofCmd klogd )" ] && killall -q klogd
    [ -n "$( $pidofCmd syslogd )" ] && killall -q syslogd
    # Give them a moment to shut down / unknown process to restart them #
    usleep 500000  #0.5 sec#
    # Background process to check and make sure built-in system loggers are terminated #
    nohup "$scribeScriptFPath" SysLoggerCheck >/dev/null 2>&1 &

    # If syslog-ng was stopped by Scribe, /opt/var/log/messages will symlink to '$syslog_loc' #
    [ -L "$optmsg" ] && $rmCmd -f "$optmsg"

    ##----------------------------------------##
    ## Modified by Martinski W. [2026-Jan-11] ##
    ##----------------------------------------##
    # If syslogd was running, '$syslog_loc' will exist as a regular file (NOT a link) #
    # This might be during bootup, or when starting Scribe #
    if [ ! -L "$syslog_loc" ]
    then
        if [ -s "$messagesLogSAVED" ]
        then
            $catCmd "$messagesLogSAVED" >> "$optmsg"
            $rmCmd -f "$messagesLogSAVED"
        fi
        log1Msg="### Top of Log File ###"
        printf '' > "$syslogD_InitRebootLogPath"

        if [ ! -d "${syslog_loc}-1" ] && \
           [ ! -L "${syslog_loc}-1" ] && \
           [ -s "${syslog_loc}-1" ]   && \
           [ "$(head -n1 "${syslog_loc}-1")" != "$log1Msg" ] && \
           [ "$(tail -n1 "${syslog_loc}-1")" != "$log1Msg" ]
        then  ## Transfer 1st part of the system log ##
            if ! "$filterSyslogInitRebootLogMsgs"
            then $catCmd "${syslog_loc}-1" >> "$optmsg"
            else $catCmd "${syslog_loc}-1" > "$syslogD_InitRebootLogPath"
            fi
        fi
        if [ -s "$syslog_loc" ]
        then
            if ! "$filterSyslogInitRebootLogMsgs"
            then $catCmd "$syslog_loc" >> "$optmsg"
            else $catCmd "$syslog_loc" >> "$syslogD_InitRebootLogPath"
            fi
        fi
        $rmCmd -f "$syslog_loc" "${syslog_loc}-1"
        $lnCmd -snf "$optmsg" "$syslog_loc"
        echo "$log1Msg" > "${syslog_loc}-1"
    fi

    # Make /jffs/syslog.log and .log-1 directories if default syslog location is NOT at /jffs #
    # Prevents system log saver from writing to jffs (not strictly necessary on newer routers) #
    if ! "$isjffs" && [ ! -d "$jffslog" ]
    then
        $rmCmd -rf "$jffslog" "${jffslog}-1"
        /bin/mkdir "$jffslog" "${jffslog}-1"
    elif "$isjffs"
    then
        # If syslogd is writing to /jffs, then ensure logfiles in /tmp #
        # are properly linked, in case something goes looking there #
        [ ! -L "$tmplog" ] && $lnCmd -snf "$optmsg" "$tmplog"
        [ ! -L "${tmplog}-1" ] && $lnCmd -snf "${syslog_loc}-1" "${tmplog}-1"
    fi

    # Create /opt/var/run/syslog-ng/ directory if it doesn't exist #
    # Not needed for older versions of syslog-ng, but doesn't hurt anything #
    [ ! -d "/opt/var/run/syslog-ng" ] && /bin/mkdir "/opt/var/run/syslog-ng"
}

PRECMD="kill_logger"
# enabling the below can be useful when having problems,
# but fills up the logfile fast
#ARGS="-v"

#EOF#
